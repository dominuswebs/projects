# functions

# PHP 8.x

function definition

function function_name ( int[type hinting] $param, $optional_param = "default", ...$variadic[variable number of arguments can be passed] ) : int [optional return type]

    [type hinting] You can specify the expected type of arguments passed to a function. If an argument of a different type is provided, PHP will issue a TypeError.

    [optional return type] You can specify the return type of a function.

function calling

function_name(required:"value") [named arguments]

    [named arguments] 

        Improved Readability: The code becomes more self-documenting as the purpose of each argument is clear from its name.
        Order Independence: You are no longer restricted by the order of parameters in the function definition.
        Skipping Default Values: You can easily pass only the arguments you need to change, while others with default values are automatically handled.
        Easier Maintenance: When refactoring or updating function signatures, named arguments can reduce the impact on existing function calls.

arrow function

    fn(...[optional arguments]) => expression [just the one]; [implicit return]

    Arrow functions support the same features as anonymous functions, 
    except that using variables from the parent scope is always automatic.

# types

     You can declare a type as nullable by prefixing a ? sign to the type. 
     For example, if a certain property can be a string or a null, you can declare it as ?string. 
     With PHP 8.0 Union Types, string|null will be functionally equivalent to ?string.

    PHP 8.0 comes with support for Union Types.
    You can declare more than one type for arguments, return types, and class properties.

    class Example {
        private int|float $foo;
        public function squareAndAdd(float|int $bar): int|float {
            return $bar ** 2 + $foo;
        }
    }

    iterable type

    There is also the `iterable` pseudo-type that is functionally equivalent to array|Traversable.

    Class type

    Class names can be used as types.

    Type variance
    
    Union type variance follows LSP. This is to ensure that all sub classes and implementations of the interface must not change the behavior of the program and still adhere to the contract. 
    This is enforced in PHP even without Union types.

    Parameter are contra-variant: Types can be widened with a super type.

        Return types are covariant: Types can be restricted to a sub type.
        Property types invariant: Types cannot be changed to a sub or super type.
        Adding or removing types to a Union

    class A{
        public function foo(string|int $foo): string|int {}
    }
    class B extends A{
        public function foo(string|int|float $foo): string {}
    }

    In the snippet above, parameter types are widened (with the addition of float type). 
    This is allowed because all programs that use class B expect them to accept all types class A accepts. 
    Class B still fulfills this contract.

    If you were to change the type in a way that class B does not fulfill the contract, this will trigger a fatal error:

    class A{
        public function foo(string|int $foo): string|int {}
    }
    class B extends A{
        public function foo(string|float $foo): string|int {}
    }

    Fatal error: Declaration of B::foo(string|float $foo): string|int must be compatible with A::foo(string|int $foo): string|int in ... on line ...

string interpolation

    In PHP, using curly braces {} within double quotes " is a feature called complex (curly) syntax for string interpolation. 
    It helps the interpreter correctly identify and parse variables, array elements, and object properties within the string, 
    especially when the variable name is immediately followed by characters that could otherwise be mistaken as part of the name.

    ex:

        $type = "apple";
        echo "I like {$type}s"; // Outputs: I like apples
        // Without braces, PHP looks for $types, which might not be defined:
        // echo "I like $types"; // Outputs: I like 


OOP

    Abstract vs interface

    In PHP, an abstract class is a base class that can have both defined methods and abstract methods, providing shared code and a common template for related classes. 
    An interface, on the other hand, is a pure contract that only defines method signatures (without implementation), which unrelated classes can implement to guarantee specific behaviors. 


        Key Differences
        
        Feature 	            Abstract Class	                                                                    Interface
        Method Implementation	Can contain both abstract (no body) and concrete (with body) methods.	            Can only declare method signatures (no body).
        Inheritance	            A class can extend only one abstract class due to single inheritance.	            A class can implement multiple interfaces.
        Properties & Constants	Can have properties (instance variables) and constants.	                            Can only have constants, not instance properties.
        Access Modifiers	    Methods and properties can have public, protected, or private access modifiers.	    All methods must be public.
        Purpose	                Used for closely related classes that share a common base implementation 	        Used to define a common behavior or "contract" for potentially unrelated classes 
                                and state ("is a" relationship).                                                    ("acts like" or "can do" relationship).

    When to Use Which

        Use an abstract class when:
            
            You want to share a common base implementation among closely related classes.
            Classes extending the abstract class will have many similar methods and properties.
            You need to define fields (state) that all subclasses can access and modify.

        Use an interface when:

            You want to define a contract that multiple, possibly unrelated, classes must follow.
            The implementing classes will have entirely different implementations of the required methods.
            A class needs to adopt multiple behaviors, which is only possible through multiple interface implementation 
            (as PHP only supports single class inheritance). 
            A common design pattern involves creating an interface to define a contract and then using an abstract class 
            to provide a default or partial implementation of that interface, which subclasses can then extend. 


